#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <tgmath.h>
#define FELD_PI 3.141592653589793
#define swap_ptr(a,b) do {void* TmP=a; a=b; b=TmP;} while (0)
int main()
{
    double _Complex _store0[16];
    double _Complex *store0 = _store0;
    double _Complex _store1[16];
    double _Complex *store1 = _store1;
    double _Complex _a2[16];
    double _Complex *a2 = _a2;
    double _Complex _a3[16];
    double _Complex *a3 = _a3;
    uint32_t let4;
    uint32_t let5;
    uint32_t let6;
    uint32_t let7;
    uint32_t let8;
    uint32_t let9;
    uint32_t let10;
    uint32_t let11;
    uint32_t let12;
    uint32_t let13;
    uint32_t let14;
    uint32_t let15;
    uint32_t let16;
    uint32_t let17;
    uint32_t let18;
    uint32_t let19;
    uint32_t let20;
    uint32_t let21;
    uint32_t let22;
    uint32_t let23;
    uint32_t let24;
    uint32_t let25;
    uint32_t let26;
    uint32_t let27;
    uint32_t let28;
    uint32_t let29;
    uint32_t let30;
    uint32_t let31;
    uint32_t let32;
    uint32_t let33;
    uint32_t let34;
    uint32_t let35;
    uint32_t let36;
    uint32_t let37;
    uint32_t let38;
    uint32_t let39;
    uint32_t let40;
    uint32_t let41;
    uint32_t let42;
    uint32_t let43;
    uint32_t let44;
    uint32_t let45;
    uint32_t let46;
    uint32_t let47;
    uint32_t let48;
    uint32_t let49;
    uint32_t let50;
    uint32_t let51;
    uint32_t let52;
    uint32_t let53;
    uint32_t let54;
    uint32_t let55;
    uint32_t let56;
    uint32_t let57;
    uint32_t let58;
    uint32_t let59;
    uint32_t let60;
    uint32_t let61;
    uint32_t let62;
    uint32_t let63;
    uint32_t let64;
    uint32_t let65;
    uint32_t let66;
    uint32_t let67;
    uint32_t let68;
    uint32_t let69;
    uint32_t let70;
    uint32_t let71;
    uint32_t let72;
    uint32_t let73;
    uint32_t let74;
    uint32_t let75;
    uint32_t let76;
    uint32_t let77;
    uint32_t let78;
    uint32_t let79;
    uint32_t let80;
    uint32_t let81;
    uint32_t let82;
    uint32_t let83;
    uint32_t let84;
    uint32_t let85;
    uint32_t let86;
    uint32_t let87;
    uint32_t let88;
    uint32_t let89;
    uint32_t let90;
    uint32_t let91;
    uint32_t let92;
    uint32_t let93;
    uint32_t let94;
    uint32_t let95;
    uint32_t let96;
    uint32_t let97;
    uint32_t let98;
    uint32_t let99;
    uint32_t let100;
    uint32_t let101;
    uint32_t let102;
    uint32_t let103;
    uint32_t let104;
    uint32_t let105;
    uint32_t let106;
    uint32_t let107;
    uint32_t let108;
    uint32_t let109;
    uint32_t let110;
    uint32_t let111;
    uint32_t let112;
    uint32_t let113;
    uint32_t let114;
    uint32_t let115;
    uint32_t let116;
    uint32_t let117;
    uint32_t let118;
    uint32_t let119;
    uint32_t let120;
    uint32_t let121;
    uint32_t let122;
    uint32_t let123;
    uint32_t let124;
    uint32_t let125;
    uint32_t let126;
    uint32_t let127;
    uint32_t r128;
    uint32_t v130;
    uint32_t r131;
    int32_t v132;
    uint32_t r142;
    uint32_t v143;
    
    assert(16 >= 16 && "copyArr: destination too small");
    memcpy(a3, a2, 16 * sizeof(double _Complex));
    assert(16 >= 1 && "ilog2: argument < 1");
    let4 = 16;
    let5 = 0;
    let6 = (uint32_t) (let4 > 65535) << 4;
    let7 = (uint32_t) (let4 > 65535) << 4;
    let8 = 16;
    let9 = 0;
    let10 = (uint32_t) (let8 > 65535) << 4;
    let11 = (uint32_t) (let8 > 65535) << 4;
    let12 = let4 >> (int32_t) let6;
    let13 = let9 | let11;
    let14 = (uint32_t) (let12 > 255) << 3;
    let15 = (uint32_t) (let12 > 255) << 3;
    let16 = 16;
    let17 = 0;
    let18 = (uint32_t) (let16 > 65535) << 4;
    let19 = (uint32_t) (let16 > 65535) << 4;
    let20 = 16;
    let21 = 0;
    let22 = (uint32_t) (let20 > 65535) << 4;
    let23 = (uint32_t) (let20 > 65535) << 4;
    let24 = let16 >> (int32_t) let18;
    let25 = let21 | let23;
    let26 = (uint32_t) (let24 > 255) << 3;
    let27 = (uint32_t) (let24 > 255) << 3;
    let28 = let12 >> (int32_t) let14;
    let29 = let25 | let27;
    let30 = (uint32_t) (let28 > 15) << 2;
    let31 = (uint32_t) (let28 > 15) << 2;
    let32 = 16;
    let33 = 0;
    let34 = (uint32_t) (let32 > 65535) << 4;
    let35 = (uint32_t) (let32 > 65535) << 4;
    let36 = 16;
    let37 = 0;
    let38 = (uint32_t) (let36 > 65535) << 4;
    let39 = (uint32_t) (let36 > 65535) << 4;
    let40 = let32 >> (int32_t) let34;
    let41 = let37 | let39;
    let42 = (uint32_t) (let40 > 255) << 3;
    let43 = (uint32_t) (let40 > 255) << 3;
    let44 = 16;
    let45 = 0;
    let46 = (uint32_t) (let44 > 65535) << 4;
    let47 = (uint32_t) (let44 > 65535) << 4;
    let48 = 16;
    let49 = 0;
    let50 = (uint32_t) (let48 > 65535) << 4;
    let51 = (uint32_t) (let48 > 65535) << 4;
    let52 = let44 >> (int32_t) let46;
    let53 = let49 | let51;
    let54 = (uint32_t) (let52 > 255) << 3;
    let55 = (uint32_t) (let52 > 255) << 3;
    let56 = let40 >> (int32_t) let42;
    let57 = let53 | let55;
    let58 = (uint32_t) (let56 > 15) << 2;
    let59 = (uint32_t) (let56 > 15) << 2;
    let60 = let28 >> (int32_t) let30;
    let61 = let57 | let59;
    let62 = (uint32_t) (let60 > 3) << 1;
    let63 = (uint32_t) (let60 > 3) << 1;
    let64 = 16;
    let65 = 0;
    let66 = (uint32_t) (let64 > 65535) << 4;
    let67 = (uint32_t) (let64 > 65535) << 4;
    let68 = 16;
    let69 = 0;
    let70 = (uint32_t) (let68 > 65535) << 4;
    let71 = (uint32_t) (let68 > 65535) << 4;
    let72 = let64 >> (int32_t) let66;
    let73 = let69 | let71;
    let74 = (uint32_t) (let72 > 255) << 3;
    let75 = (uint32_t) (let72 > 255) << 3;
    let76 = 16;
    let77 = 0;
    let78 = (uint32_t) (let76 > 65535) << 4;
    let79 = (uint32_t) (let76 > 65535) << 4;
    let80 = 16;
    let81 = 0;
    let82 = (uint32_t) (let80 > 65535) << 4;
    let83 = (uint32_t) (let80 > 65535) << 4;
    let84 = let76 >> (int32_t) let78;
    let85 = let81 | let83;
    let86 = (uint32_t) (let84 > 255) << 3;
    let87 = (uint32_t) (let84 > 255) << 3;
    let88 = let72 >> (int32_t) let74;
    let89 = let85 | let87;
    let90 = (uint32_t) (let88 > 15) << 2;
    let91 = (uint32_t) (let88 > 15) << 2;
    let92 = 16;
    let93 = 0;
    let94 = (uint32_t) (let92 > 65535) << 4;
    let95 = (uint32_t) (let92 > 65535) << 4;
    let96 = 16;
    let97 = 0;
    let98 = (uint32_t) (let96 > 65535) << 4;
    let99 = (uint32_t) (let96 > 65535) << 4;
    let100 = let92 >> (int32_t) let94;
    let101 = let97 | let99;
    let102 = (uint32_t) (let100 > 255) << 3;
    let103 = (uint32_t) (let100 > 255) << 3;
    let104 = 16;
    let105 = 0;
    let106 = (uint32_t) (let104 > 65535) << 4;
    let107 = (uint32_t) (let104 > 65535) << 4;
    let108 = 16;
    let109 = 0;
    let110 = (uint32_t) (let108 > 65535) << 4;
    let111 = (uint32_t) (let108 > 65535) << 4;
    let112 = let104 >> (int32_t) let106;
    let113 = let109 | let111;
    let114 = (uint32_t) (let112 > 255) << 3;
    let115 = (uint32_t) (let112 > 255) << 3;
    let116 = let100 >> (int32_t) let102;
    let117 = let113 | let115;
    let118 = (uint32_t) (let116 > 15) << 2;
    let119 = (uint32_t) (let116 > 15) << 2;
    let120 = let88 >> (int32_t) let90;
    let121 = let117 | let119;
    let122 = (uint32_t) (let120 > 3) << 1;
    let123 = (uint32_t) (let120 > 3) << 1;
    let124 = let60 >> (int32_t) let62;
    let125 = let121 | let123;
    let126 = (uint32_t) (let124 > 1) << 0;
    let127 = (uint32_t) (let124 > 1) << 0;
    r128 = let125 | let127;
    
    double _Complex _a129[1 << (int32_t) (r128 - 1)];
    double _Complex *a129 = _a129;
    
    for (v130 = 0; v130 < 1 << (int32_t) (r128 - 1); v130++) {
        assert(v130 < 1 << (int32_t) (r128 - 1) &&
            "setArr: index out of bounds");
        assert(v130 < 1 << (int32_t) (r128 - 1) &&
            "indexing outside of Pull vector");
        a129[v130 + 0] = exp(I * (-2.0 * FELD_PI * (double) v130 /
                                  (double) (1 << (int32_t) r128)));
    }
    assert(16 >= 16 && "copyArr: destination too small");
    memcpy(store1, a3, 16 * sizeof(double _Complex));
    swap_ptr(store0, store1);
    r131 = 16;
    for (v132 = (int32_t) r128 - 1; v132 >= 0; v132--) {
        uint32_t v133;
        
        assert(16 % 2 == 0 && "unroll: length not divisible by 2");
        for (v133 = 0; v133 < 16; v133 = v133 + 2) {
            uint32_t r134;
            double _Complex v135;
            uint32_t r138;
            double _Complex v139;
            
            r134 = v133 + 0;
            assert(r134 < 16 && "setArr: index out of bounds");
            assert(r134 < 16 && "indexing outside of Pull vector");
            if ((bool) (r134 & 1 << (int32_t) (uint32_t) v132)) {
                double _Complex v136;
                
                assert(r134 < 16 && "indexing outside of Pull vector");
                assert(0 + (1 << (int32_t) (r128 - 1)) <= 1 << (int32_t) (r128 -
                                                                          1) &&
                    "invalid IArr slice");
                assert((r134 & ~(~0 << (int32_t) (uint32_t) v132)) <<
                    (int32_t) r128 - 1 - (int32_t) (uint32_t) v132 < 1 <<
                    (int32_t) (r128 - 1) && "arrIx: index out of bounds");
                assert(r134 < 16 && "indexing outside of Pull vector");
                assert(0 <= 1 << (int32_t) (r128 - 1) && "invalid IArr slice");
                assert(r134 < 16 && "indexing outside of Pull vector");
                assert(0 + r131 <= 16 && "invalid IArr slice");
                assert(r134 < r131 && "indexing outside of Pull vector");
                assert(r134 < 16 && "indexing outside of Pull vector");
                if ((bool) (r134 & 1 << (int32_t) (uint32_t) v132)) {
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r134 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v136 = store0[(r134 ^ 1 << (int32_t) (uint32_t) v132) + (0 +
                                                                             0)] -
                        store0[r134 + (0 + 0)];
                } else {
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r134 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v136 = store0[r134 + (0 + 0)] + store0[(r134 ^ 1 <<
                                                            (int32_t) (uint32_t) v132) +
                                                           (0 + 0)];
                }
                v135 = a129[((r134 & ~(~0 << (int32_t) (uint32_t) v132)) <<
                             (int32_t) r128 - 1 - (int32_t) (uint32_t) v132) +
                            (0 + 0)] * v136;
            } else {
                double _Complex v137;
                
                assert(r134 < 16 && "indexing outside of Pull vector");
                assert(0 + r131 <= 16 && "invalid IArr slice");
                assert(r134 < r131 && "indexing outside of Pull vector");
                assert(r134 < 16 && "indexing outside of Pull vector");
                if ((bool) (r134 & 1 << (int32_t) (uint32_t) v132)) {
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r134 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v137 = store0[(r134 ^ 1 << (int32_t) (uint32_t) v132) + (0 +
                                                                             0)] -
                        store0[r134 + (0 + 0)];
                } else {
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r134 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r134 < r131 && "indexing outside of Pull vector");
                    assert(r134 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v137 = store0[r134 + (0 + 0)] + store0[(r134 ^ 1 <<
                                                            (int32_t) (uint32_t) v132) +
                                                           (0 + 0)];
                }
                v135 = v137;
            }
            store1[r134 + 0] = v135;
            r138 = v133 + 1;
            assert(r138 < 16 && "setArr: index out of bounds");
            assert(r138 < 16 && "indexing outside of Pull vector");
            if ((bool) (r138 & 1 << (int32_t) (uint32_t) v132)) {
                double _Complex v140;
                
                assert(r138 < 16 && "indexing outside of Pull vector");
                assert(0 + (1 << (int32_t) (r128 - 1)) <= 1 << (int32_t) (r128 -
                                                                          1) &&
                    "invalid IArr slice");
                assert((r138 & ~(~0 << (int32_t) (uint32_t) v132)) <<
                    (int32_t) r128 - 1 - (int32_t) (uint32_t) v132 < 1 <<
                    (int32_t) (r128 - 1) && "arrIx: index out of bounds");
                assert(r138 < 16 && "indexing outside of Pull vector");
                assert(0 <= 1 << (int32_t) (r128 - 1) && "invalid IArr slice");
                assert(r138 < 16 && "indexing outside of Pull vector");
                assert(0 + r131 <= 16 && "invalid IArr slice");
                assert(r138 < r131 && "indexing outside of Pull vector");
                assert(r138 < 16 && "indexing outside of Pull vector");
                if ((bool) (r138 & 1 << (int32_t) (uint32_t) v132)) {
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r138 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v140 = store0[(r138 ^ 1 << (int32_t) (uint32_t) v132) + (0 +
                                                                             0)] -
                        store0[r138 + (0 + 0)];
                } else {
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r138 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v140 = store0[r138 + (0 + 0)] + store0[(r138 ^ 1 <<
                                                            (int32_t) (uint32_t) v132) +
                                                           (0 + 0)];
                }
                v139 = a129[((r138 & ~(~0 << (int32_t) (uint32_t) v132)) <<
                             (int32_t) r128 - 1 - (int32_t) (uint32_t) v132) +
                            (0 + 0)] * v140;
            } else {
                double _Complex v141;
                
                assert(r138 < 16 && "indexing outside of Pull vector");
                assert(0 + r131 <= 16 && "invalid IArr slice");
                assert(r138 < r131 && "indexing outside of Pull vector");
                assert(r138 < 16 && "indexing outside of Pull vector");
                if ((bool) (r138 & 1 << (int32_t) (uint32_t) v132)) {
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r138 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v141 = store0[(r138 ^ 1 << (int32_t) (uint32_t) v132) + (0 +
                                                                             0)] -
                        store0[r138 + (0 + 0)];
                } else {
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert((r138 ^ 1 << (int32_t) (uint32_t) v132) < r131 &&
                        "arrIx: index out of bounds");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 + r131 <= 16 && "invalid IArr slice");
                    assert(r138 < r131 && "indexing outside of Pull vector");
                    assert(r138 < 16 && "indexing outside of Pull vector");
                    assert(0 <= 16 && "invalid IArr slice");
                    v141 = store0[r138 + (0 + 0)] + store0[(r138 ^ 1 <<
                                                            (int32_t) (uint32_t) v132) +
                                                           (0 + 0)];
                }
                v139 = v141;
            }
            store1[r138 + 0] = v139;
        }
        swap_ptr(store0, store1);
        r131 = 16;
    }
    assert(0 <= 16 && "invalid IArr slice");
    if (!((0 + 0) == 0)) {
        assert(0 + r131 <= 16 && "invalid IArr slice");
        assert(16 >= r131 && "copyArr: destination too small");
        assert(0 <= 16 && "invalid IArr slice");
        assert(0 + r131 <= 16 && "invalid IArr slice");
        memcpy(store1, store0 + (0 + 0), r131 * sizeof(double _Complex));
        swap_ptr(store0, store1);
    }
    assert(0 + r131 <= 16 && "invalid IArr slice");
    r142 = r131;
    for (v143 = 1; v143 < r128; v143++) {
        uint32_t v144;
        
        assert(0 + r142 <= 16 && "invalid IArr slice");
        assert(r142 % 2 == 0 && "unroll: length not divisible by 2");
        assert(0 + r142 <= 16 && "invalid IArr slice");
        for (v144 = 0; v144 < r142; v144 = v144 + 2) {
            uint32_t r145;
            uint32_t r146;
            
            r145 = v144 + 0;
            assert(r145 < 16 && "setArr: index out of bounds");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(((r145 >> 1 >> (int32_t) v143 << 1 | (r145 & 1)) <<
                    (int32_t) v143 | (r145 >> 1 & ~(~0 << (int32_t) v143))) <
                r142 && "arrIx: index out of bounds");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r145 < r142 && "indexing outside of Pull vector");
            assert(0 <= 16 && "invalid IArr slice");
            store1[r145 + 0] = store0[((r145 >> 1 >> (int32_t) v143 << 1 |
                                        (r145 & 1)) << (int32_t) v143 | (r145 >>
                                                                         1 &
                                                                         ~(~0 <<
                                                                           (int32_t) v143))) +
                                      (0 + 0)];
            r146 = v144 + 1;
            assert(r146 < 16 && "setArr: index out of bounds");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(((r146 >> 1 >> (int32_t) v143 << 1 | (r146 & 1)) <<
                    (int32_t) v143 | (r146 >> 1 & ~(~0 << (int32_t) v143))) <
                r142 && "arrIx: index out of bounds");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 + r142 <= 16 && "invalid IArr slice");
            assert(r146 < r142 && "indexing outside of Pull vector");
            assert(0 <= 16 && "invalid IArr slice");
            store1[r146 + 0] = store0[((r146 >> 1 >> (int32_t) v143 << 1 |
                                        (r146 & 1)) << (int32_t) v143 | (r146 >>
                                                                         1 &
                                                                         ~(~0 <<
                                                                           (int32_t) v143))) +
                                      (0 + 0)];
        }
        swap_ptr(store0, store1);
        assert(0 + r142 <= 16 && "invalid IArr slice");
        r142 = r142;
    }
    return 0;
}